## 第六章 堆排序

时间复杂度：O（nlgn）

堆排序具有空间原址性:任何时候只需要常数个额外的元素空间存储临时数据

### 预备知识：

完全二叉树(Complete Binary Tree): 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。



### 知识梳理

#### 6.1 堆

1）概述：（二叉）堆是一个数组（A）, 可以看成近似的完全二叉树,树上的每一节点对应数组中的一个数，除最低层外，该树是完全充满的，且从左往右填充      

2）下标计算：由于数组小标从0开始，故：

思考方式：就是想把索引从0开始，转化成从1开始，然后算出结果x，则实际索引为（x - 1）

举例：LeftChild = （（i + 1） x 2） -1 = 2i + 1

```
Parent（i）
  return floor(i/2) - 1  // 之前搞错了，牢记 ：不是 floor((i-1)/2)

LeftChild(i)
  return 2i + 1

RightChild
  return 2i + 2
```

4）分类：最大堆 和 最小堆

最大堆：除根节点之外的所有节点满足 A[Parent(i)] ≥ A(i)，当然根节点是堆的最大值，最小堆定义类似

用途：堆排序中使用的是最大堆，最小堆通常用来构造优先队列

5）性质：包含 n 个元素的堆，可以看成一颗完全二叉树，堆的高度为O（lgn）


6) 堆排序概述

    1. MAX-HEAPIFY 过程：时间复杂度O（lgn），维护最大堆性质的关键
    2. BUILD-MAX-HEAP 过程: 时间复杂度O（n), 作用是将一个无序数组建立成一个堆
    3. HEAPSORT 过程: 时间复杂度O（nlgn），对一个数组原址排序
    4. MAX-HEAP-INSERT, HEAP-EXTRACT-MAX, HEAP-INCREASE-KEY, HEAP-MAXIMUM 过程：时间复杂度都是 O（lgn），作用是建立一个优先队列



### 习题解答

6.1.1（根节点的高度是0）

答 ：由于堆可以看成一颗完全二叉树，则（0 ~ h-1）层的节点之和为 pow(2,h) - 1；
    第 h 层最少一个元素，最多 pow（2， h）（即2的 h 次方）个元素，所以元素
    最少为：pow（2，h）
    最多为：pow（2，h+1） - 1


6.1.2

答：由6.1.1知道
    pow（2，h）≤ n ≤ pow（2, h+1) - 1
  =>   h ≤ lgn 且 h ≥ lg（n+1） -1 > lgn -1
  =>   lgn -1 < h ≤ lgn
  =>   h = floor(h)

6.1.3(反证)

6.1.4

答： 位于叶节点

6.1.5

答：如果是升序排列的话，就是一个最小堆

6.1.6

答：不是

6.1.7

答：我们知道，堆是一个完全二叉树，最后一个节点 n 的父节点为 floor（n/2）,则其父节点的右兄弟（如果有的话）没有孩子，即叶节点
如果有的话，则左孩子节点为 2(floor（n/2）+ 1) + 1   > = n+1 > n ，与题设矛盾
所以说存储 n 个元素的堆的叶节点的下标分别是 floor（n/2）+ 1, floor(n/2) + 2, ..., n


### 6.2维护堆的性质

**MAX-HEAPIFY 是维护最大堆的重要性质**

过程：调用 MAX-HEAPIFY时

      1. 输入数组 A 和下标 i，假设根节点 Left（i） 和 Right（i）的二叉树都是最大堆
      2. A[i] 可能小于其孩子，这时违反了最大堆的性质
      3. MAX-HEAPIFY 的作用就是让 A[i] 的值在最大堆里逐级下降，从而使下标为 i 的根节点继续遵循最大堆的性质





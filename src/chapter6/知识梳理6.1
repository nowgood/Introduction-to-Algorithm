第六章 堆排序

时间复杂度：O（nlgn）
堆排序具有空间原址性:任何时候只需要常数个额外的元素空间存储临时数据

预备知识：
1）floor() 下取整
   ceil()  上取整

2）完全二叉树(Complete Binary Tree)
若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，
第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

3) 符号：pow（a，b）= a 的 b 次方


知识梳理
6.1 堆
1）概述：（二叉）堆是一个数组（A）, 可以看成近似的完全二叉树,树上的每一节点对应数组中的一个数，
         除最低层外，该树是完全充满的，且从左往右填充

2）属性：A.length 与 A.heap-size(其中 0 ≤ A.heap-size ≤ A.size)
        A[0...A.head-size - 1] 存储的是堆的有效元素

3）下标计算：由于数组小标从0开始，故：
思考方式：就是想把索引从0开始，转化成从1开始，然后算出结果x，则实际索引为（x - 1）
举例：LeftChild = （（i + 1） x 2） -1 = 2i + 1

Parent（i）
return floor(i/2) - 1  // 之前搞错了，牢记 ：不是 floor((i-1)/2)

LeftChild(i)
return 2i + 1

RightChild
return 2i + 2

4）分类：最大堆 和 最小堆
最大堆：除根节点之外的所有节点满足 A[Parent(i)] ≥ A(i)，当然根节点是堆的最大值，最小堆定义类似
用途：堆排序中使用的是最大堆，最小堆通常用来构造优先队列

5）性质：包含 n 个元素的堆，可以看成一颗完全二叉树，堆的高度为O（lgn）


6) 堆排序概述

    MAX-HEAPIFY 过程：时间复杂度O（lgn），维护最大堆性质的关键
    BUILD-MAX-HEAP 过程: 时间复杂度O（n), 作用是将一个无序数组建立成一个堆
    HEAPSORT 过程: 时间复杂度O（nlgn），对一个数组原址排序
    MAX-HEAP-INSERT, HEAP-EXTRACT-MAX, HEAP-INCREASE-KEY, HEAP-MAXIMUM 过程：时间复杂度都是 O（lgn），作用是建立一个优先队列



习题解答

6.1.1（根节点的高度是0）
答 ：由于堆可以看成一颗完全二叉树，则（0 ~ h-1）层的节点之和为 pow(2,h) - 1；
    第 h 层最少一个元素，最多 pow（2， h）（即2的 h 次方）个元素，所以元素
    最少为：pow（2，h）
    最多为：pow（2，h+1） - 1


6.1.2
答：由6.1.1知道
    pow（2，h）≤ n ≤ pow（2, h+1) - 1
  =>   h ≤ lgn 且 h ≥ lg（n+1） -1 > lgn -1
  =>   lgn -1 < h ≤ lgn
  =>   h = floor(h)

6.1.3(反证)

6.1.4
答： 位于叶节点

6.1.5
答：如果是升序排列的话，就是一个最小堆

6.1.6
答：不是

6.1.7
答：我们知道，堆是一个完全二叉树，最后一个节点 n 的父节点为 floor（n/2）,则其父节点的右兄弟（如果有的话）没有孩子，即叶节点
如果有的话，则左孩子节点为 2(floor（n/2）+ 1) + 1   > = n+1 > n ，与题设矛盾
所以说存储 n 个元素的堆的叶节点的下标分别是 floor（n/2）+ 1, floor(n/2) + 2, ..., n







